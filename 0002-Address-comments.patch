From a1f346c28e04b067e4c3f1f19c27770964fb1254 Mon Sep 17 00:00:00 2001
From: Chuanqi Xu <yedeng.yd@linux.alibaba.com>
Date: Mon, 9 Oct 2023 17:35:45 +0800
Subject: [PATCH 2/3] Address comments

Address comments in
https://github.com/llvm/llvm-project/pull/66462#pullrequestreview-1650642633
---
 clang-tools-extra/clangd/CMakeLists.txt       |   2 +-
 .../clangd/GlobalCompilationDatabase.cpp      |  16 +-
 .../clangd/GlobalCompilationDatabase.h        |  13 +-
 .../clangd/ModuleDependencyScanner.cpp        |  65 ++++----
 .../clangd/ModuleDependencyScanner.h          |  42 ++++--
 clang-tools-extra/clangd/ModuleFilesInfo.h    | 118 ---------------
 clang-tools-extra/clangd/ParsedAST.cpp        |   8 +-
 clang-tools-extra/clangd/Preamble.cpp         |  20 ++-
 clang-tools-extra/clangd/Preamble.h           |   4 +-
 ...eFilesInfo.cpp => PrerequisiteModules.cpp} |  90 ++++++------
 .../clangd/PrerequisiteModules.h              | 139 ++++++++++++++++++
 clang-tools-extra/clangd/ProjectModules.h     |  54 +++++++
 .../clangd/unittests/CMakeLists.txt           |   2 +-
 .../unittests/ModuleDependencyScannerTest.cpp |  35 +++--
 ...foTest.cpp => PrerequisiteModulesTest.cpp} |  71 ++++-----
 15 files changed, 378 insertions(+), 301 deletions(-)
 delete mode 100644 clang-tools-extra/clangd/ModuleFilesInfo.h
 rename clang-tools-extra/clangd/{ModuleFilesInfo.cpp => PrerequisiteModules.cpp} (73%)
 create mode 100644 clang-tools-extra/clangd/PrerequisiteModules.h
 create mode 100644 clang-tools-extra/clangd/ProjectModules.h
 rename clang-tools-extra/clangd/unittests/{ModuleFilesInfoTest.cpp => PrerequisiteModulesTest.cpp} (68%)

diff --git a/clang-tools-extra/clangd/CMakeLists.txt b/clang-tools-extra/clangd/CMakeLists.txt
index bcfb49551a02..14e798e313dc 100644
--- a/clang-tools-extra/clangd/CMakeLists.txt
+++ b/clang-tools-extra/clangd/CMakeLists.txt
@@ -98,7 +98,7 @@ add_clang_library(clangDaemon
   InlayHints.cpp
   JSONTransport.cpp
   ModuleDependencyScanner.cpp
-  ModuleFilesInfo.cpp
+  PrerequisiteModules.cpp
   PathMapping.cpp
   Protocol.cpp
   Quality.cpp
diff --git a/clang-tools-extra/clangd/GlobalCompilationDatabase.cpp b/clang-tools-extra/clangd/GlobalCompilationDatabase.cpp
index bcc8f4f0dd9e..5396c2a7f03d 100644
--- a/clang-tools-extra/clangd/GlobalCompilationDatabase.cpp
+++ b/clang-tools-extra/clangd/GlobalCompilationDatabase.cpp
@@ -9,6 +9,7 @@
 #include "GlobalCompilationDatabase.h"
 #include "Config.h"
 #include "FS.h"
+#include "ProjectModules.h"
 #include "SourceCode.h"
 #include "support/Logger.h"
 #include "support/Path.h"
@@ -729,9 +730,8 @@ DirectoryBasedGlobalCompilationDatabase::getProjectInfo(PathRef File) const {
   return Res->PI;
 }
 
-std::vector<std::string>
-DirectoryBasedGlobalCompilationDatabase::getAllFilesInProjectOf(
-    PathRef File) const {
+std::shared_ptr<ProjectModules>
+DirectoryBasedGlobalCompilationDatabase::getProjectModules(PathRef File) const {
   CDBLookupRequest Req;
   Req.FileName = File;
   Req.ShouldBroadcast = false;
@@ -740,7 +740,7 @@ DirectoryBasedGlobalCompilationDatabase::getAllFilesInProjectOf(
   auto Res = lookupCDB(Req);
   if (!Res)
     return {};
-  return Res->CDB->getAllFiles();
+  return std::make_shared<ScanningAllProjectModules>(Res->CDB->getAllFiles(), *this, Opts.TFS);
 }
 
 OverlayCDB::OverlayCDB(const GlobalCompilationDatabase *Base,
@@ -819,11 +819,11 @@ std::optional<ProjectInfo> DelegatingCDB::getProjectInfo(PathRef File) const {
   return Base->getProjectInfo(File);
 }
 
-std::vector<std::string>
-DelegatingCDB::getAllFilesInProjectOf(PathRef File) const {
+std::shared_ptr<ProjectModules>
+DelegatingCDB::getProjectModules(PathRef File) const {
   if (!Base)
-    return {};
-  return Base->getAllFilesInProjectOf(File);
+    return nullptr;
+  return Base->getProjectModules(File);
 }
 
 tooling::CompileCommand DelegatingCDB::getFallbackCommand(PathRef File) const {
diff --git a/clang-tools-extra/clangd/GlobalCompilationDatabase.h b/clang-tools-extra/clangd/GlobalCompilationDatabase.h
index eaeff8d627a0..38eaba54b58c 100644
--- a/clang-tools-extra/clangd/GlobalCompilationDatabase.h
+++ b/clang-tools-extra/clangd/GlobalCompilationDatabase.h
@@ -25,6 +25,8 @@
 namespace clang {
 namespace clangd {
 
+class ProjectModules;
+
 struct ProjectInfo {
   // The directory in which the compilation database was discovered.
   // Empty if directory-based compilation database discovery was not used.
@@ -45,8 +47,9 @@ public:
     return std::nullopt;
   }
 
-  virtual std::vector<std::string> getAllFilesInProjectOf(PathRef File) const {
-    return {};
+  /// Get the modules in the closest project to \p File
+  virtual std::shared_ptr<ProjectModules> getProjectModules(PathRef File) const {
+    return nullptr;
   }
 
   /// Makes a guess at how to build a file.
@@ -79,7 +82,8 @@ public:
   getCompileCommand(PathRef File) const override;
 
   std::optional<ProjectInfo> getProjectInfo(PathRef File) const override;
-  std::vector<std::string> getAllFilesInProjectOf(PathRef File) const override;
+
+  std::shared_ptr<ProjectModules> getProjectModules(PathRef File) const override;
 
   tooling::CompileCommand getFallbackCommand(PathRef File) const override;
 
@@ -126,7 +130,8 @@ public:
   /// Returns the path to first directory containing a compilation database in
   /// \p File's parents.
   std::optional<ProjectInfo> getProjectInfo(PathRef File) const override;
-  std::vector<std::string> getAllFilesInProjectOf(PathRef File) const override;
+
+  std::shared_ptr<ProjectModules> getProjectModules(PathRef File) const override;
 
   bool blockUntilIdle(Deadline Timeout) const override;
 
diff --git a/clang-tools-extra/clangd/ModuleDependencyScanner.cpp b/clang-tools-extra/clangd/ModuleDependencyScanner.cpp
index edadfe45d82c..bbe44107d32d 100644
--- a/clang-tools-extra/clangd/ModuleDependencyScanner.cpp
+++ b/clang-tools-extra/clangd/ModuleDependencyScanner.cpp
@@ -10,12 +10,9 @@
 
 namespace clang {
 namespace clangd {
-using P1689Rule = tooling::dependencies::P1689Rule;
-
-std::optional<P1689Rule> ModuleDependencyScanner::scan(PathRef FilePath) {
-  if (ScanningCache.count(FilePath))
-    return ScanningCache[FilePath];
 
+std::optional<ModuleDependencyScanner::ModuleDependencyInfo>
+ModuleDependencyScanner::scan(PathRef FilePath) {
   std::optional<tooling::CompileCommand> Cmd = CDB.getCompileCommand(FilePath);
 
   if (!Cmd)
@@ -25,62 +22,54 @@ std::optional<P1689Rule> ModuleDependencyScanner::scan(PathRef FilePath) {
 
   llvm::SmallString<128> FilePathDir(FilePath);
   llvm::sys::path::remove_filename(FilePathDir);
-  DependencyScanningTool ScanningTool(
-      Service,
-      TFS ? TFS->view(FilePathDir) : llvm::vfs::createPhysicalFileSystem());
+  DependencyScanningTool ScanningTool(Service, TFS.view(FilePathDir));
 
-  llvm::Expected<P1689Rule> Result =
+  llvm::Expected<P1689Rule> P1689Result =
       ScanningTool.getP1689ModuleDependencyFile(*Cmd, Cmd->Directory);
 
-  if (auto E = Result.takeError()) {
+  if (auto E = P1689Result.takeError()) {
     // Ignore any error.
     llvm::consumeError(std::move(E));
     return std::nullopt;
   }
 
-  if (Result->Provides)
-    ModuleNameToSourceMapper[Result->Provides->ModuleName] = FilePath;
+  ModuleDependencyInfo Result;
 
-  ScanningCache[FilePath] = *Result;
-  return *Result;
-}
+  if (P1689Result->Provides) {
+    ModuleNameToSource[P1689Result->Provides->ModuleName] = FilePath;
+    Result.ModuleName = P1689Result->Provides->ModuleName;
+  }
 
-void ModuleDependencyScanner::globalScan(PathRef File) {
-  std::vector<std::string> AllFiles = CDB.getAllFilesInProjectOf(File);
+  for (auto &Required : P1689Result->Requires)
+    Result.RequiredModules.push_back(Required.ModuleName);
 
+  return Result;
+}
+
+void ModuleDependencyScanner::globalScan(const std::vector<std::string> &AllFiles) {
   for (auto &File : AllFiles)
     scan(File);
+
+  GlobalScanned = true;
 }
 
 PathRef ModuleDependencyScanner::getSourceForModuleName(StringRef ModuleName) const {
-  if (!ModuleNameToSourceMapper.count(ModuleName))
+  assert(GlobalScanned && "We should only call getSourceForModuleName after calling globalScan()");
+
+  if (!ModuleNameToSource.count(ModuleName))
     return {};
 
-  return ModuleNameToSourceMapper.at(ModuleName);
+  return ModuleNameToSource.at(ModuleName);
 }
 
 std::vector<std::string>
-ModuleDependencyScanner::getRequiredModules(PathRef File) const {
-  if (!ScanningCache.count(File))
+ModuleDependencyScanner::getRequiredModules(PathRef File) {
+  auto ScanningResult = scan(File);
+  if (!ScanningResult)
     return {};
-
-  const P1689Rule &CachedResult = ScanningCache.at(File);
-  std::vector<std::string> Result;
-
-  for (const auto &Info : CachedResult.Requires)
-    Result.push_back(Info.ModuleName);
-
-  return Result;
+  
+  return ScanningResult->RequiredModules;
 }
 
-StringRef ModuleDependencyScanner::getModuleName(PathRef File) const {
-  if (!ScanningCache.count(File))
-    return {};
-
-  if (!ScanningCache.at(File).Provides)
-    return {};
-
-  return ScanningCache.at(File).Provides->ModuleName;
-}
 } // namespace clangd
 } // namespace clang
diff --git a/clang-tools-extra/clangd/ModuleDependencyScanner.h b/clang-tools-extra/clangd/ModuleDependencyScanner.h
index 1d6eb58fda59..3b9fed8eb40b 100644
--- a/clang-tools-extra/clangd/ModuleDependencyScanner.h
+++ b/clang-tools-extra/clangd/ModuleDependencyScanner.h
@@ -22,7 +22,7 @@
 namespace clang {
 namespace clangd {
 
-/// A scanner to produce P1689 format for C++20 Modules.
+/// A scanner to query the dependency information for C++20 Modules.
 ///
 /// The scanner can scan a single file with `scan(PathRef)` member function
 /// or scan the whole project with `globalScan(PathRef)` member function. See
@@ -30,46 +30,58 @@ namespace clangd {
 class ModuleDependencyScanner {
 public:
   ModuleDependencyScanner(const GlobalCompilationDatabase &CDB,
-                          const ThreadsafeFS *TFS)
+                          const ThreadsafeFS &TFS)
       : CDB(CDB), TFS(TFS),
         Service(tooling::dependencies::ScanningMode::CanonicalPreprocessing,
                 tooling::dependencies::ScanningOutputFormat::P1689) {}
 
+  // The scanned modules dependency information for a specific source file.
+  struct ModuleDependencyInfo {
+    // The name of the module if the file is a module unit.
+    std::optional<std::string> ModuleName;
+    // A list of names for the modules that the file directly depends.
+    std::vector<std::string> RequiredModules;
+  };
+
   /// Scanning the single file specified by \param FilePath.
-  std::optional<clang::tooling::dependencies::P1689Rule> scan(PathRef FilePath);
+  /// NOTE: This is only used by unittests for external uses.
+  std::optional<ModuleDependencyInfo> scan(PathRef FilePath);
 
   /// Scanning every source file in the current project to get the
   /// <module-name> to <module-unit-source> map.
   /// It looks unefficiency to scan the whole project especially for
   /// every version of every file!
-  /// TODO: We should find a efficient method to get the <module-name>
+  /// TODO: We should find an efficient method to get the <module-name>
   /// to <module-unit-source> map. We can make it either by providing
   /// a global module dependency scanner to monitor every file. Or we
   /// can simply require the build systems (or even if the end users)
   /// to provide the map.
-  void globalScan(PathRef File);
+  void globalScan(const std::vector<std::string> &AllFiles);
+  bool isGlobalScanned() const { return GlobalScanned; }
 
+  /// Get the source file from the module name. Note that the language
+  /// guarantees all the module names are unique in a valid program.
+  /// This function should only be called after globalScan.
+  /// FIXME: Maybe we should handle the corner cases.
   PathRef getSourceForModuleName(StringRef ModuleName) const;
 
   /// Return the direct required modules. Indirect required modules are not
   /// included.
-  std::vector<std::string> getRequiredModules(PathRef File) const;
-  StringRef getModuleName(PathRef File) const;
-
-  const ThreadsafeFS *getThreadsafeFS() const { return TFS; }
-
-  const GlobalCompilationDatabase &getCompilationDatabase() const { return CDB; }
+  std::vector<std::string> getRequiredModules(PathRef File);
 
 private:
   const GlobalCompilationDatabase &CDB;
-  const ThreadsafeFS *TFS;
+  const ThreadsafeFS &TFS;
+
+  // Whether the scanner has scanned the project globally.
+  bool GlobalScanned = false;
 
   clang::tooling::dependencies::DependencyScanningService Service;
 
-  // Map source file to P1689 Result.
-  llvm::StringMap<clang::tooling::dependencies::P1689Rule> ScanningCache;
+  // TODO: Add a scanning cache.
+
   // Map module name to source file path.
-  llvm::StringMap<std::string> ModuleNameToSourceMapper;
+  llvm::StringMap<std::string> ModuleNameToSource;
 };
 
 } // namespace clangd
diff --git a/clang-tools-extra/clangd/ModuleFilesInfo.h b/clang-tools-extra/clangd/ModuleFilesInfo.h
deleted file mode 100644
index 557233f87076..000000000000
--- a/clang-tools-extra/clangd/ModuleFilesInfo.h
+++ /dev/null
@@ -1,118 +0,0 @@
-//===----------------- ModuleFilesInfo.h -------------------------*- C++-*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-//
-// Experimental support for C++20 Modules.
-//
-// Currently we simplify the implementations by preventing reusing module files
-// across different versions and different source files. But this is clearly a
-// waste of time and space in the end of the day.
-//
-// FIXME: Supporting reusing module files across different versions and different
-// source files.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_MODULEFILESINFO_H
-#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_MODULEFILESINFO_H
-
-#include "Compiler.h"
-#include "GlobalCompilationDatabase.h"
-#include "ModuleDependencyScanner.h"
-#include "support/Path.h"
-
-#include "clang/Lex/HeaderSearchOptions.h"
-
-#include "llvm/ADT/SmallString.h"
-#include "llvm/ADT/StringMap.h"
-
-namespace clang {
-namespace clangd {
-
-/// Store module files information for a single file.
-///
-/// A ModuleFilesInfo should only be initialized by
-/// `ModuleFilesInfo::buildModuleFilesInfoFor(PathRef, const ThreadsafeFS *, const GlobalCompilationDatabase &)`
-/// static member method. This method will block the current thread and build all the needed
-/// module files. All the built module files won't be shared with other source files.
-///
-/// Users can detect whether the ModuleFilesInfo is still up to date by calling
-/// the `CanReuse()` member function.
-///
-/// The users should call `ReplaceHeaderSearchOptions(...)` or `ReplaceCompileCommands(CompileCommand&)`
-/// member function to update the compilation commands to select the built module files first.
-struct ModuleFilesInfo {
-  ModuleFilesInfo() = default;
-  ~ModuleFilesInfo();
-
-  ModuleFilesInfo(const ModuleFilesInfo &) = delete;
-  ModuleFilesInfo operator=(const ModuleFilesInfo &) = delete;
-
-  ModuleFilesInfo(ModuleFilesInfo &&Other)
-      : Successed(std::exchange(Other.Successed, false)),
-        UniqueModuleFilesPathPrefix(
-            std::move(Other.UniqueModuleFilesPathPrefix)),
-        DependentModuleNames(std::move(Other.DependentModuleNames)) {
-    Other.UniqueModuleFilesPathPrefix.clear();
-  }
-  ModuleFilesInfo &operator=(ModuleFilesInfo &&Other) {
-    if (this == &Other)
-      return *this;
-
-    this->~ModuleFilesInfo();
-    new (this) ModuleFilesInfo(std::move(Other));
-
-    return *this;
-  }
-
-  /// Build all the required module files for \param File.
-  /// Note that only the module files recorded by \param CDB can be built.
-  static ModuleFilesInfo
-  buildModuleFilesInfoFor(PathRef File, const ThreadsafeFS *TFS,
-                          const GlobalCompilationDatabase &CDB);
-
-  /// Return true if the modile file specified by ModuleName is built.
-  /// Note that this interface will only check the existence of the module
-  /// file instead of checking the validness of the module file. 
-  bool IsModuleUnitBuilt(StringRef ModuleName) const;
-
-  /// Change commands to load the module files recorded in this ModuleFilesInfo
-  /// first.
-  void ReplaceHeaderSearchOptions(HeaderSearchOptions &Options) const;
-  void ReplaceCompileCommands(tooling::CompileCommand &Cmd) const;
-  void ReplaceCompileCommands(tooling::CompileCommand &Cmd,
-                              StringRef OutputModuleName) const;
-
-  /// Whether or not the built module files are up to date.
-  /// Note that this can only be used after building the module files.
-  bool CanReuse(const CompilerInvocation &CI,
-                llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>) const;
-
-  /// NOTE: This shouldn't be used by external users except unittests.
-  llvm::SmallString<256> getModuleFilePath(StringRef ModuleName) const;
-
-private:
-  ModuleFilesInfo(PathRef MainFile, const GlobalCompilationDatabase &CDB);
-
-  bool IsInited() const { return !UniqueModuleFilesPathPrefix.empty(); }
-  bool buildModuleFile(PathRef ModuleUnitFileName,
-                       ModuleDependencyScanner &Scanner);
-
-  // Whether the last built is successed.
-  // May change in `IsModuleUnitBuilt`.
-  mutable bool Successed = false;
-
-  llvm::SmallString<256> UniqueModuleFilesPathPrefix;
-  // The language guarantees that the module name is unique in a program.
-  // May change in `IsModuleUnitBuilt`.
-  mutable llvm::StringSet<> DependentModuleNames;
-};
-
-} // namespace clangd
-} // namespace clang
-
-#endif
diff --git a/clang-tools-extra/clangd/ParsedAST.cpp b/clang-tools-extra/clangd/ParsedAST.cpp
index 3e9480093ebe..3eca64fa8bb1 100644
--- a/clang-tools-extra/clangd/ParsedAST.cpp
+++ b/clang-tools-extra/clangd/ParsedAST.cpp
@@ -429,10 +429,10 @@ ParsedAST::build(llvm::StringRef Filename, const ParseInputs &Inputs,
           L->sawDiagnostic(D, Diag);
       });
 
-  // Replace header search options to load the built module files recorded
+  // Adjust header search options to load the built module files recorded
   // in DependentModulesInfo.
-  if (Preamble)
-    Preamble->DependentModulesInfo.ReplaceHeaderSearchOptions(
+  if (Preamble && Preamble->DependentModulesInfo)
+    Preamble->DependentModulesInfo->adjustHeaderSearchOptions(
         CI->getHeaderSearchOpts());
 
   std::optional<PreamblePatch> Patch;
@@ -449,8 +449,6 @@ ParsedAST::build(llvm::StringRef Filename, const ParseInputs &Inputs,
       llvm::MemoryBuffer::getMemBufferCopy(Inputs.Contents, Filename), VFS,
       *DiagConsumer);
 
-  // Clangd Modules TODO: refactor the command line options of `Clang` here.
-
   if (!Clang) {
     // The last diagnostic contains information about the reason of this
     // failure.
diff --git a/clang-tools-extra/clangd/Preamble.cpp b/clang-tools-extra/clangd/Preamble.cpp
index 6e0a39f40e7f..425dea5085da 100644
--- a/clang-tools-extra/clangd/Preamble.cpp
+++ b/clang-tools-extra/clangd/Preamble.cpp
@@ -661,11 +661,6 @@ std::shared_ptr<const PreambleData> buildPreamble(
   WallTimer PreambleTimer;
   PreambleTimer.startTimer();
 
-  ModuleFilesInfo DependentModulesInfo =
-      !ExperimentalModulesSupport
-          ? ModuleFilesInfo{}
-          : ModuleFilesInfo::buildModuleFilesInfoFor(FileName, Inputs.TFS, CDB);
-
   auto BuiltPreamble = PrecompiledPreamble::Build(
       CI, ContentsBuffer.get(), Bounds, *PreambleDiagsEngine,
       Stats ? TimedFS : StatCacheFS, std::make_shared<PCHContainerOperations>(),
@@ -704,8 +699,16 @@ std::shared_ptr<const PreambleData> buildPreamble(
     Result->Pragmas = std::make_shared<const include_cleaner::PragmaIncludes>(
         CapturedInfo.takePragmaIncludes());
 
-    // FIXME: If there is no headers?
-    Result->DependentModulesInfo = std::move(DependentModulesInfo);
+    if (ExperimentalModulesSupport) {
+      WallTimer PrerequisiteModuleTimer;
+      PrerequisiteModuleTimer.startTimer();
+      Result->DependentModulesInfo = PrerequisiteModules::buildPrerequisiteModulesFor(FileName, Inputs.TFS, CDB);
+      PrerequisiteModuleTimer.stopTimer();
+
+      log("Built prerequisite module for file {0} in {1} seconds",
+          FileName, PrerequisiteModuleTimer.getTime());
+    }
+
     Result->Macros = CapturedInfo.takeMacros();
     Result->Marks = CapturedInfo.takeMarks();
     Result->StatCache = StatCache;
@@ -747,7 +750,8 @@ bool isPreambleCompatible(const PreambleData &Preamble,
   return compileCommandsAreEqual(Inputs.CompileCommand,
                                  Preamble.CompileCommand) &&
          Preamble.Preamble.CanReuse(CI, *ContentsBuffer, Bounds, *VFS) &&
-         Preamble.DependentModulesInfo.CanReuse(CI, VFS);
+         (!Preamble.DependentModulesInfo ||
+          Preamble.DependentModulesInfo->canReuse(CI, VFS));
 }
 
 void escapeBackslashAndQuotes(llvm::StringRef Text, llvm::raw_ostream &OS) {
diff --git a/clang-tools-extra/clangd/Preamble.h b/clang-tools-extra/clangd/Preamble.h
index fb390c025597..7339922afe3a 100644
--- a/clang-tools-extra/clangd/Preamble.h
+++ b/clang-tools-extra/clangd/Preamble.h
@@ -28,7 +28,7 @@
 #include "FS.h"
 #include "Headers.h"
 
-#include "ModuleFilesInfo.h"
+#include "PrerequisiteModules.h"
 
 #include "clang-include-cleaner/Record.h"
 #include "support/Path.h"
@@ -108,7 +108,7 @@ struct PreambleData {
   // Captures #include-mapping information in #included headers.
   std::shared_ptr<const include_cleaner::PragmaIncludes> Pragmas;
   // Information about module files for this preamble.
-  ModuleFilesInfo DependentModulesInfo;
+  std::optional<PrerequisiteModules> DependentModulesInfo;
   // Macros defined in the preamble section of the main file.
   // Users care about headers vs main-file, not preamble vs non-preamble.
   // These should be treated as main-file entities e.g. for code completion.
diff --git a/clang-tools-extra/clangd/ModuleFilesInfo.cpp b/clang-tools-extra/clangd/PrerequisiteModules.cpp
similarity index 73%
rename from clang-tools-extra/clangd/ModuleFilesInfo.cpp
rename to clang-tools-extra/clangd/PrerequisiteModules.cpp
index 845ff01ca09d..424336156646 100644
--- a/clang-tools-extra/clangd/ModuleFilesInfo.cpp
+++ b/clang-tools-extra/clangd/PrerequisiteModules.cpp
@@ -1,4 +1,4 @@
-//===----------------- ModuleFilesInfo.cpp -----------------------*- C++-*-===//
+//===----------------- PrerequisiteModules.cpp -----------------------*- C++-*-===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
@@ -6,7 +6,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "ModuleFilesInfo.h"
+#include "PrerequisiteModules.h"
+#include "ProjectModules.h"
 #include "support/Logger.h"
 
 #include "clang/Frontend/FrontendAction.h"
@@ -30,7 +31,7 @@ llvm::SmallString<128> getAbsolutePath(const tooling::CompileCommand &Cmd) {
 }
 } // namespace
 
-ModuleFilesInfo::ModuleFilesInfo(PathRef MainFile,
+PrerequisiteModules::PrerequisiteModules(PathRef MainFile,
                                  const GlobalCompilationDatabase &CDB) {
   std::optional<ProjectInfo> PI = CDB.getProjectInfo(MainFile);
   if (!PI)
@@ -48,9 +49,8 @@ ModuleFilesInfo::ModuleFilesInfo(PathRef MainFile,
   log("Initialized module files to {0}", UniqueModuleFilesPathPrefix.str());
 }
 
-ModuleFilesInfo::~ModuleFilesInfo() {
+PrerequisiteModules::~PrerequisiteModules() {
   DependentModuleNames.clear();
-  Successed = false;
 
   if (UniqueModuleFilesPathPrefix.empty())
     return;
@@ -60,7 +60,7 @@ ModuleFilesInfo::~ModuleFilesInfo() {
 }
 
 llvm::SmallString<256>
-ModuleFilesInfo::getModuleFilePath(StringRef ModuleName) const {
+PrerequisiteModules::getModuleFilePath(StringRef ModuleName) const {
   llvm::SmallString<256> ModuleFilePath;
 
   ModuleFilePath = UniqueModuleFilesPathPrefix;
@@ -75,7 +75,7 @@ ModuleFilesInfo::getModuleFilePath(StringRef ModuleName) const {
   return ModuleFilePath;
 }
 
-bool ModuleFilesInfo::IsModuleUnitBuilt(StringRef ModuleName) const {
+bool PrerequisiteModules::isModuleUnitBuilt(StringRef ModuleName) const {
   if (!DependentModuleNames.count(ModuleName))
     return false;
 
@@ -83,13 +83,11 @@ bool ModuleFilesInfo::IsModuleUnitBuilt(StringRef ModuleName) const {
   if (llvm::sys::fs::exists(BMIPath))
     return true;
 
-  Successed = false;
-
   DependentModuleNames.erase(ModuleName);
   return false;
 }
 
-void ModuleFilesInfo::ReplaceHeaderSearchOptions(
+void PrerequisiteModules::adjustHeaderSearchOptions(
     HeaderSearchOptions &Options) const {
   if (!IsInited())
     return;
@@ -99,7 +97,7 @@ void ModuleFilesInfo::ReplaceHeaderSearchOptions(
 
   for (auto Iter = Options.PrebuiltModuleFiles.begin();
        Iter != Options.PrebuiltModuleFiles.end();) {
-    if (IsModuleUnitBuilt(Iter->first)) {
+    if (isModuleUnitBuilt(Iter->first)) {
       Iter = Options.PrebuiltModuleFiles.erase(Iter);
       continue;
     }
@@ -108,7 +106,7 @@ void ModuleFilesInfo::ReplaceHeaderSearchOptions(
   }
 }
 
-void ModuleFilesInfo::ReplaceCompileCommands(
+void PrerequisiteModules::adjustCompileCommands(
     tooling::CompileCommand &Cmd) const {
   if (!IsInited())
     return;
@@ -128,7 +126,7 @@ void ModuleFilesInfo::ReplaceCompileCommands(
     // already built.
     if (LHS == "-fmodule-file" && RHS.contains("=")) {
       const auto &[ModuleName, _] = RHS.split("=");
-      if (IsModuleUnitBuilt(ModuleName))
+      if (isModuleUnitBuilt(ModuleName))
         continue;
     }
 
@@ -136,39 +134,41 @@ void ModuleFilesInfo::ReplaceCompileCommands(
   }
 }
 
-void ModuleFilesInfo::ReplaceCompileCommands(tooling::CompileCommand &Cmd,
+void PrerequisiteModules::adjustCompileCommands(tooling::CompileCommand &Cmd,
                                              StringRef OutputModuleName) const {
   if (!IsInited())
     return;
 
-  ReplaceCompileCommands(Cmd);
+  adjustCompileCommands(Cmd);
 
   Cmd.Output = getModuleFilePath(OutputModuleName).str().str();
 }
 
-bool ModuleFilesInfo::buildModuleFile(PathRef ModuleUnitFileName,
-                                      ModuleDependencyScanner &Scanner) {
+bool PrerequisiteModules::buildModuleFile(StringRef ModuleName,
+                                          std::shared_ptr<ProjectModules> MDB,
+                                          const GlobalCompilationDatabase &CDB,
+                                          const ThreadsafeFS * TFS) {
+  PathRef ModuleUnitFileName = MDB->getSourceForModuleName(ModuleName);
   if (ModuleUnitFileName.empty())
     return false;
 
-  for (auto &ModuleName : Scanner.getRequiredModules(ModuleUnitFileName)) {
+  for (auto &RequiredModuleName : MDB->getRequiredModules(ModuleUnitFileName)) {
     // Return early if there are errors building the module file.
-    if (!IsModuleUnitBuilt(ModuleName) &&
-        !buildModuleFile(Scanner.getSourceForModuleName(ModuleName), Scanner)) {
-      log("Failed to build module {0}", ModuleName);
+    if (!isModuleUnitBuilt(RequiredModuleName) &&
+        !buildModuleFile(RequiredModuleName, MDB, CDB, TFS)) {
+      log("Failed to build module {0}", RequiredModuleName);
       return false;
     }
   }
 
-  auto Cmd =
-      Scanner.getCompilationDatabase().getCompileCommand(ModuleUnitFileName);
+  auto Cmd = CDB.getCompileCommand(ModuleUnitFileName);
   if (!Cmd)
     return false;
 
-  ReplaceCompileCommands(*Cmd, Scanner.getModuleName(ModuleUnitFileName));
+  adjustCompileCommands(*Cmd, ModuleName);
 
   ParseInputs Inputs;
-  Inputs.TFS = Scanner.getThreadsafeFS();
+  Inputs.TFS = TFS;
   Inputs.CompileCommand = std::move(*Cmd);
 
   IgnoreDiagnostics IgnoreDiags;
@@ -200,45 +200,39 @@ bool ModuleFilesInfo::buildModuleFile(PathRef ModuleUnitFileName,
   if (Clang->getDiagnostics().hasErrorOccurred())
     return false;
 
-  DependentModuleNames.insert(Scanner.getModuleName(ModuleUnitFileName));
+  DependentModuleNames.insert(ModuleName);
 
   return true;
 }
 
-ModuleFilesInfo
-ModuleFilesInfo::buildModuleFilesInfoFor(PathRef File, const ThreadsafeFS *TFS,
-                                         const GlobalCompilationDatabase &CDB) {
-  ModuleDependencyScanner Scanner(CDB, TFS);
-
-  std::optional<tooling::dependencies::P1689Rule> ScanningResult =
-      Scanner.scan(File);
-  if (!ScanningResult)
-    return {};
+std::optional<PrerequisiteModules>
+PrerequisiteModules::buildPrerequisiteModulesFor(PathRef File, const ThreadsafeFS *TFS,
+                                                 const GlobalCompilationDatabase &CDB) {
+  std::shared_ptr<ProjectModules> MDB = CDB.getProjectModules(File);
+  if (!MDB)
+    return std::nullopt;
 
-  ModuleFilesInfo ModulesInfo(File, CDB);
+  std::vector<std::string> RequiredModules = MDB->getRequiredModules(File);
+  if (RequiredModules.empty())
+    return std::nullopt;
 
-  Scanner.globalScan(File);
+  PrerequisiteModules ModulesInfo(File, CDB);
 
-  for (auto &Info : ScanningResult->Requires)
+  for (const std::string &RequiredModuleName : RequiredModules)
     // Return early if there is any error.
-    if (!ModulesInfo.buildModuleFile(
-            Scanner.getSourceForModuleName(Info.ModuleName), Scanner)) {
-      log("Failed to build module {0}", Info.ModuleName);
-      return ModulesInfo;
+    if (!ModulesInfo.buildModuleFile(RequiredModuleName, MDB, CDB, TFS)) {
+      log("Failed to build module {0}", RequiredModuleName);
+      return PrerequisiteModules();
     }
 
-  ModulesInfo.Successed = true;
   return ModulesInfo;
 }
 
-bool ModuleFilesInfo::CanReuse(
+bool PrerequisiteModules::canReuse(
     const CompilerInvocation &CI,
     llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS) const {
   // Try to avoid expensive check as much as possible.
   if (!IsInited())
-    return true;
-
-  if (!Successed)
     return false;
 
   CompilerInstance Clang;
@@ -254,7 +248,7 @@ bool ModuleFilesInfo::CanReuse(
   if (!Clang.createTarget())
     return false;
 
-  ReplaceHeaderSearchOptions(Clang.getHeaderSearchOpts());
+  adjustHeaderSearchOptions(Clang.getHeaderSearchOpts());
   // Since we don't need to compile the source code actually, the TU kind here
   // doesn't matter.
   Clang.createPreprocessor(TU_Complete);
diff --git a/clang-tools-extra/clangd/PrerequisiteModules.h b/clang-tools-extra/clangd/PrerequisiteModules.h
new file mode 100644
index 000000000000..d67d5a4f46bf
--- /dev/null
+++ b/clang-tools-extra/clangd/PrerequisiteModules.h
@@ -0,0 +1,139 @@
+//===----------------- PrerequisiteModules.h -------------------------*- C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// Experimental support for C++20 Modules.
+//
+// Currently we simplify the implementations by preventing reusing module files
+// across different versions and different source files. But this is clearly a
+// waste of time and space in the end of the day.
+//
+// FIXME: Supporting reusing module files across different versions and different
+// source files.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_PREREQUISITEMODULES_H
+#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_PREREQUISITEMODULES_H
+
+#include "Compiler.h"
+#include "GlobalCompilationDatabase.h"
+#include "ModuleDependencyScanner.h"
+#include "support/Path.h"
+
+#include "clang/Lex/HeaderSearchOptions.h"
+
+#include "llvm/ADT/SmallString.h"
+#include "llvm/ADT/StringMap.h"
+
+namespace clang {
+namespace clangd {
+
+/// Build and store all the needed module files information to parse a single
+/// source file. e.g.,
+///
+///   ```
+///   // a.cppm
+///   export module a;
+///   
+///   // b.cppm
+///   export module b;
+///   import a;
+///
+///   // c.cppm
+///   export module c;
+///   import a;
+///   ```
+///
+/// For the source file `c.cppm`, an instance of the class will build and store
+/// the module files for `a.cppm` and `b.cppm`. But the module file for `c.cppm` won't
+/// be built. Since it is not needed to parse `c.cppm`.
+///
+/// All the built module files won't be shared with other instances of the class.
+/// So that we can avoid worrying thread safety.
+///
+/// A PrerequisiteModules instace should only be initialized by
+/// `PrerequisiteModules::buildPrerequisiteModulesFor(...)`.
+///
+/// Users can detect whether the PrerequisiteModules is still up to date by calling
+/// the `CanReuse()` member function.
+///
+/// The users should call `adjustHeaderSearchOptions(...)` or `adjustCompileCommands(CompileCommand&)`
+/// member function to update the compilation commands to select the built module files first.
+struct PrerequisiteModules {
+  ~PrerequisiteModules();
+
+  PrerequisiteModules(const PrerequisiteModules &) = delete;
+  PrerequisiteModules operator=(const PrerequisiteModules &) = delete;
+
+  PrerequisiteModules(PrerequisiteModules &&Other)
+      : UniqueModuleFilesPathPrefix(
+            std::move(Other.UniqueModuleFilesPathPrefix)),
+        DependentModuleNames(std::move(Other.DependentModuleNames)) {
+    Other.UniqueModuleFilesPathPrefix.clear();
+  }
+  PrerequisiteModules &operator=(PrerequisiteModules &&Other) {
+    if (this == &Other)
+      return *this;
+
+    this->~PrerequisiteModules();
+    new (this) PrerequisiteModules(std::move(Other));
+
+    return *this;
+  }
+
+  /// Build all the required module files for \param File.
+  ///
+  /// This method will block the current thread and build all the needed
+  /// module files.
+  /// Note that only the module files recorded by \param CDB can be built.
+  static std::optional<PrerequisiteModules>
+  buildPrerequisiteModulesFor(PathRef File, const ThreadsafeFS *TFS,
+                              const GlobalCompilationDatabase &CDB);
+
+  /// Change commands to load the module files recorded in this PrerequisiteModules
+  /// first.
+  void adjustHeaderSearchOptions(HeaderSearchOptions &Options) const;
+  /// NOTE: This shouldn't be used by external users except unittests.
+  void adjustCompileCommands(tooling::CompileCommand &Cmd) const;
+  void adjustCompileCommands(tooling::CompileCommand &Cmd,
+                             StringRef OutputModuleName) const;
+
+  /// Whether or not the built module files are up to date.
+  /// Note that this can only be used after building the module files.
+  bool canReuse(const CompilerInvocation &CI,
+                llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>) const;
+
+  /// NOTE: This shouldn't be used by external users except unittests.
+  llvm::SmallString<256> getModuleFilePath(StringRef ModuleName) const;
+
+  /// Return true if the modile file specified by ModuleName is built.
+  /// Note that this interface will only check the existence of the module
+  /// file instead of checking the validness of the module file. 
+  /// NOTE: This shouldn't be used by external users except unittests.
+  bool isModuleUnitBuilt(StringRef ModuleName) const;
+
+private:
+  PrerequisiteModules() = default;
+  PrerequisiteModules(PathRef MainFile, const GlobalCompilationDatabase &CDB);
+
+  bool IsInited() const { return !UniqueModuleFilesPathPrefix.empty(); }
+  bool buildModuleFile(StringRef ModuleName,
+                       std::shared_ptr<ProjectModules> MDB,
+                       const GlobalCompilationDatabase &CDB,
+                       const ThreadsafeFS * TFS);
+
+  llvm::SmallString<256> UniqueModuleFilesPathPrefix;
+  // The language guarantees that the module name is unique in a program.
+  // May change in `isModuleUnitBuilt`.
+  mutable llvm::StringSet<> DependentModuleNames;
+};
+
+} // namespace clangd
+} // namespace clang
+
+#endif
diff --git a/clang-tools-extra/clangd/ProjectModules.h b/clang-tools-extra/clangd/ProjectModules.h
new file mode 100644
index 000000000000..a3095d0014a4
--- /dev/null
+++ b/clang-tools-extra/clangd/ProjectModules.h
@@ -0,0 +1,54 @@
+//===------------------ ProjectModules.h -------------------------*- C++-*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_PROJECTMODULES_H
+#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_PROJECTMODULES_H
+
+#include "ModuleDependencyScanner.h"
+
+namespace clang {
+namespace clangd {
+
+/// An interface to query the modules information in the project.
+/// This should be obtained by
+/// `GlobalCompilationDatabase::getProjectModules(PathRef)`.
+///
+/// TODO: The existing `ScanningAllProjectModules` is not efficient. See the
+/// comments in ModuleDependencyScanner for detail.
+class ProjectModules {
+public:
+  virtual std::vector<std::string> getRequiredModules(PathRef File) = 0;
+  virtual PathRef getSourceForModuleName(StringRef ModuleName) = 0;
+};
+
+class ScanningAllProjectModules : public ProjectModules {
+public:
+  ScanningAllProjectModules(std::vector<std::string> &&AllFiles,
+                 const GlobalCompilationDatabase &CDB,
+                 const ThreadsafeFS& TFS) : AllFiles(std::move(AllFiles)), Scanner(CDB, TFS) {}
+
+  std::vector<std::string> getRequiredModules(PathRef File) override {
+    return Scanner.getRequiredModules(File);
+  }
+  PathRef getSourceForModuleName(StringRef ModuleName) override {
+    if (!Scanner.isGlobalScanned())
+      Scanner.globalScan(AllFiles);
+
+    return Scanner.getSourceForModuleName(ModuleName);
+  }
+
+private:
+  std::vector<std::string> AllFiles;
+
+  ModuleDependencyScanner Scanner;
+};
+
+}
+}
+
+#endif
diff --git a/clang-tools-extra/clangd/unittests/CMakeLists.txt b/clang-tools-extra/clangd/unittests/CMakeLists.txt
index cd79534c6a97..529b8d2a1173 100644
--- a/clang-tools-extra/clangd/unittests/CMakeLists.txt
+++ b/clang-tools-extra/clangd/unittests/CMakeLists.txt
@@ -73,7 +73,7 @@ add_unittest(ClangdUnitTests ClangdTests
   LSPBinderTests.cpp
   LSPClient.cpp
   ModuleDependencyScannerTest.cpp
-  ModuleFilesInfoTest.cpp
+  PrerequisiteModulesTest.cpp
   ModulesTests.cpp
   ParsedASTTests.cpp
   PathMappingTests.cpp
diff --git a/clang-tools-extra/clangd/unittests/ModuleDependencyScannerTest.cpp b/clang-tools-extra/clangd/unittests/ModuleDependencyScannerTest.cpp
index d046c02fbff0..74cc084c7897 100644
--- a/clang-tools-extra/clangd/unittests/ModuleDependencyScannerTest.cpp
+++ b/clang-tools-extra/clangd/unittests/ModuleDependencyScannerTest.cpp
@@ -43,19 +43,19 @@ import D;
   MockCompilationDatabase CDB(TestDir);
   CDB.ExtraClangFlags.push_back("-std=c++20");
 
-  ModuleDependencyScanner Scanner(CDB, &TFS);
-  std::optional<P1689Rule> ScanningResult = Scanner.scan(getFullPath("A.cppm"));
+  ModuleDependencyScanner Scanner(CDB, TFS);
+  std::optional<ModuleDependencyScanner::ModuleDependencyInfo> ScanningResult = Scanner.scan(getFullPath("A.cppm"));
   EXPECT_TRUE(ScanningResult);
 
-  EXPECT_TRUE(ScanningResult->Provides);
-  EXPECT_EQ(ScanningResult->Provides->ModuleName, "A");
+  EXPECT_TRUE(ScanningResult->ModuleName);
+  EXPECT_EQ(*ScanningResult->ModuleName, "A");
 
-  EXPECT_EQ(ScanningResult->Requires.size(), 5u);
-  EXPECT_EQ(ScanningResult->Requires[0].ModuleName, "foo");
-  EXPECT_EQ(ScanningResult->Requires[1].ModuleName, "A:partA");
-  EXPECT_EQ(ScanningResult->Requires[2].ModuleName, "A:partB");
-  EXPECT_EQ(ScanningResult->Requires[3].ModuleName, "C");
-  EXPECT_EQ(ScanningResult->Requires[4].ModuleName, "D");
+  EXPECT_EQ(ScanningResult->RequiredModules.size(), 5u);
+  EXPECT_EQ(ScanningResult->RequiredModules[0], "foo");
+  EXPECT_EQ(ScanningResult->RequiredModules[1], "A:partA");
+  EXPECT_EQ(ScanningResult->RequiredModules[2], "A:partB");
+  EXPECT_EQ(ScanningResult->RequiredModules[3], "C");
+  EXPECT_EQ(ScanningResult->RequiredModules[4], "D");
 }
 
 TEST_F(ModuleDependencyScannerTests, GlobalScanning) {
@@ -140,8 +140,13 @@ import D;
 
   std::unique_ptr<GlobalCompilationDatabase> CDB =
       getGlobalCompilationDatabase();
-  ModuleDependencyScanner Scanner(*CDB.get(), &TFS);
-  Scanner.globalScan(getFullPath("A.cppm"));
+  ModuleDependencyScanner Scanner(*CDB.get(), TFS);
+  Scanner.globalScan({getFullPath("A.cppm"),
+                      getFullPath("foo.cppm"),
+                      getFullPath("A-partA.cppm"),
+                      getFullPath("A-partB.cppm"),
+                      getFullPath("C.cppm"),
+                      getFullPath("D.cppm")});
 
   EXPECT_TRUE(Scanner.getSourceForModuleName("foo").endswith("foo.cppm"));
   EXPECT_TRUE(Scanner.getSourceForModuleName("A").endswith("A.cppm"));
@@ -166,12 +171,6 @@ import D;
   EXPECT_EQ(Scanner.getRequiredModules(getFullPath("A.cppm"))[2], "A:partB");
   EXPECT_EQ(Scanner.getRequiredModules(getFullPath("A.cppm"))[3], "C");
   EXPECT_EQ(Scanner.getRequiredModules(getFullPath("A.cppm"))[4], "D");
-
-  EXPECT_EQ(Scanner.getModuleName(getFullPath("A.cppm")), "A");
-  EXPECT_EQ(Scanner.getModuleName(getFullPath("A-partA.cppm")), "A:partA");
-  EXPECT_EQ(Scanner.getModuleName(getFullPath("A-partB.cppm")), "A:partB");
-  EXPECT_EQ(Scanner.getModuleName(getFullPath("C.cppm")), "C");
-  EXPECT_EQ(Scanner.getModuleName(getFullPath("D.cppm")), "D");
 }
 
 } // namespace
diff --git a/clang-tools-extra/clangd/unittests/ModuleFilesInfoTest.cpp b/clang-tools-extra/clangd/unittests/PrerequisiteModulesTest.cpp
similarity index 68%
rename from clang-tools-extra/clangd/unittests/ModuleFilesInfoTest.cpp
rename to clang-tools-extra/clangd/unittests/PrerequisiteModulesTest.cpp
index e7f7352970df..6f48e9dc91bc 100644
--- a/clang-tools-extra/clangd/unittests/ModuleFilesInfoTest.cpp
+++ b/clang-tools-extra/clangd/unittests/PrerequisiteModulesTest.cpp
@@ -1,4 +1,4 @@
-//===--------------- ModuleFilesInfoTests.cpp -------------------*- C++ -*-===//
+//===--------------- PrerequisiteModulesTests.cpp -------------------*- C++ -*-===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
@@ -10,18 +10,18 @@
 /// code mode.
 #ifndef _WIN32
 
-#include "ModuleFilesInfo.h"
+#include "PrerequisiteModules.h"
 #include "ModulesTestSetup.h"
 
 using namespace clang;
 using namespace clang::clangd;
 
 namespace {
-class ModuleFilesInfoTests : public ModuleTestSetup {
+class PrerequisiteModulesTests : public ModuleTestSetup {
   
 };
 
-TEST_F(ModuleFilesInfoTests, ModuleFilesInfoTest) {
+TEST_F(PrerequisiteModulesTests, PrerequisiteModulesTest) {
   addFile("build/compile_commands.json", R"cpp(
 [
 {
@@ -84,25 +84,26 @@ export module L;
 
   std::unique_ptr<GlobalCompilationDatabase> CDB =
       getGlobalCompilationDatabase();
-  auto MInfo = ModuleFilesInfo::buildModuleFilesInfoFor(getFullPath("M.cppm"),
+  auto MInfo = PrerequisiteModules::buildPrerequisiteModulesFor(getFullPath("M.cppm"),
                                                         &TFS, *CDB);
-  // buildModuleFilesInfoFor won't built the module itself.
-  EXPECT_FALSE(MInfo.IsModuleUnitBuilt("M"));
+  // buildPrerequisiteModulesFor won't built the module itself.
+  EXPECT_FALSE(MInfo);
 
   // Module N shouldn't be able to be built.
-  auto NInfo = ModuleFilesInfo::buildModuleFilesInfoFor(getFullPath("N.cppm"),
+  auto NInfo = PrerequisiteModules::buildPrerequisiteModulesFor(getFullPath("N.cppm"),
                                                         &TFS, *CDB);
-  EXPECT_TRUE(NInfo.IsModuleUnitBuilt("M"));
-  EXPECT_TRUE(NInfo.getModuleFilePath("M").endswith("M.pcm"));
-  EXPECT_TRUE(NInfo.IsModuleUnitBuilt("N:Part"));
-  EXPECT_TRUE(NInfo.getModuleFilePath("N:Part").endswith("N-Part.pcm"));
+  EXPECT_TRUE(NInfo);
+  EXPECT_TRUE(NInfo->isModuleUnitBuilt("M"));
+  EXPECT_TRUE(NInfo->getModuleFilePath("M").endswith("M.pcm"));
+  EXPECT_TRUE(NInfo->isModuleUnitBuilt("N:Part"));
+  EXPECT_TRUE(NInfo->getModuleFilePath("N:Part").endswith("N-Part.pcm"));
 
   ParseInputs NInput = getInputs("N.cppm", *CDB);
   std::vector<std::string> CC1Args;
   std::unique_ptr<CompilerInvocation> Invocation =
       getCompilerInvocation(NInput);
-  // Test that `ModuleFilesInfo::CanReuse` works basically.
-  EXPECT_TRUE(NInfo.CanReuse(*Invocation, TFS.view(TestDir)));
+  // Test that `PrerequisiteModules::canReuse` works basically.
+  EXPECT_TRUE(NInfo->canReuse(*Invocation, TFS.view(TestDir)));
 
   // Test that we can still reuse the NInfo after we touch a unrelated file.
   {
@@ -112,13 +113,13 @@ module;
 export module L;
 export int ll = 43;
   )cpp");
-    EXPECT_TRUE(NInfo.CanReuse(*Invocation, TFS.view(TestDir)));
+    EXPECT_TRUE(NInfo->canReuse(*Invocation, TFS.view(TestDir)));
 
     addFile("bar.h", R"cpp(
 inline void bar() {}
 inline void bar(int) {}
   )cpp");
-    EXPECT_TRUE(NInfo.CanReuse(*Invocation, TFS.view(TestDir)));
+    EXPECT_TRUE(NInfo->canReuse(*Invocation, TFS.view(TestDir)));
   }
 
   // Test that we can't reuse the NInfo after we touch a related file.
@@ -129,21 +130,21 @@ module;
 export module M;
 export int mm = 44;
   )cpp");
-    EXPECT_FALSE(NInfo.CanReuse(*Invocation, TFS.view(TestDir)));
+    EXPECT_FALSE(NInfo->canReuse(*Invocation, TFS.view(TestDir)));
 
-    NInfo = ModuleFilesInfo::buildModuleFilesInfoFor(getFullPath("N.cppm"),
+    NInfo = PrerequisiteModules::buildPrerequisiteModulesFor(getFullPath("N.cppm"),
                                                      &TFS, *CDB);
-    EXPECT_TRUE(NInfo.CanReuse(*Invocation, TFS.view(TestDir)));
+    EXPECT_TRUE(NInfo->canReuse(*Invocation, TFS.view(TestDir)));
 
     addFile("foo.h", R"cpp(
 inline void foo() {}
 inline void foo(int) {}
   )cpp");
-    EXPECT_FALSE(NInfo.CanReuse(*Invocation, TFS.view(TestDir)));
+    EXPECT_FALSE(NInfo->canReuse(*Invocation, TFS.view(TestDir)));
 
-    NInfo = ModuleFilesInfo::buildModuleFilesInfoFor(getFullPath("N.cppm"),
+    NInfo = PrerequisiteModules::buildPrerequisiteModulesFor(getFullPath("N.cppm"),
                                                      &TFS, *CDB);
-    EXPECT_TRUE(NInfo.CanReuse(*Invocation, TFS.view(TestDir)));
+    EXPECT_TRUE(NInfo->canReuse(*Invocation, TFS.view(TestDir)));
   }
 
   addFile("N-part.cppm", R"cpp(
@@ -151,21 +152,21 @@ export module N:Part;
 // Intentioned to make it uncompilable.
 export int NPart = 4LIdjwldijaw
   )cpp");
-  EXPECT_FALSE(NInfo.CanReuse(*Invocation, TFS.view(TestDir)));
-  NInfo = ModuleFilesInfo::buildModuleFilesInfoFor(getFullPath("N.cppm"), &TFS,
+  EXPECT_FALSE(NInfo->canReuse(*Invocation, TFS.view(TestDir)));
+  NInfo = PrerequisiteModules::buildPrerequisiteModulesFor(getFullPath("N.cppm"), &TFS,
                                                    *CDB);
   // So NInfo should be unreusable even after rebuild.
-  EXPECT_FALSE(NInfo.CanReuse(*Invocation, TFS.view(TestDir)));
+  EXPECT_FALSE(NInfo->canReuse(*Invocation, TFS.view(TestDir)));
 
   addFile("N-part.cppm", R"cpp(
 export module N:Part;
 export int NPart = 43;
   )cpp");
-  EXPECT_FALSE(NInfo.CanReuse(*Invocation, TFS.view(TestDir)));
-  NInfo = ModuleFilesInfo::buildModuleFilesInfoFor(getFullPath("N.cppm"), &TFS,
+  EXPECT_FALSE(NInfo->canReuse(*Invocation, TFS.view(TestDir)));
+  NInfo = PrerequisiteModules::buildPrerequisiteModulesFor(getFullPath("N.cppm"), &TFS,
                                                    *CDB);
   // So NInfo should be unreusable even after rebuild.
-  EXPECT_TRUE(NInfo.CanReuse(*Invocation, TFS.view(TestDir)));
+  EXPECT_TRUE(NInfo->canReuse(*Invocation, TFS.view(TestDir)));
 
   // Test that if we changed the modification time of the file, the module files
   // info is still reusable if its content doesn't change.
@@ -173,7 +174,7 @@ export int NPart = 43;
 export module N:Part;
 export int NPart = 43;
   )cpp");
-  EXPECT_TRUE(NInfo.CanReuse(*Invocation, TFS.view(TestDir)));
+  EXPECT_TRUE(NInfo->canReuse(*Invocation, TFS.view(TestDir)));
 
   addFile("N.cppm", R"cpp(
 export module N;
@@ -183,20 +184,20 @@ import M;
 export int nn = 43;
   )cpp");
   // NInfo should be reusable after we change its content.
-  EXPECT_TRUE(NInfo.CanReuse(*Invocation, TFS.view(TestDir)));
+  EXPECT_TRUE(NInfo->canReuse(*Invocation, TFS.view(TestDir)));
 
   {
-    llvm::StringRef MPath = NInfo.getModuleFilePath("M");
+    llvm::StringRef MPath = NInfo->getModuleFilePath("M");
     llvm::SmallString<256> ModuleFilesPath = MPath;
     llvm::sys::path::remove_filename(ModuleFilesPath);
 
     // Check that
-    // `ModuleFilesInfo::ReplaceCompileCommands(tooling::CompileCommand &Cmd)`
+    // `PrerequisiteModules::adjustCompileCommands(tooling::CompileCommand &Cmd)`
     // can replace compile commands correctly.
     std::optional<tooling::CompileCommand> NCmd =
         CDB->getCompileCommand(getFullPath("N.cppm"));
     EXPECT_TRUE(NCmd);
-    NInfo.ReplaceCompileCommands(*NCmd);
+    NInfo->adjustCompileCommands(*NCmd);
     EXPECT_EQ(
         NCmd->CommandLine[1],
         llvm::Twine("-fprebuilt-module-path=" + ModuleFilesPath.str()).str());
@@ -207,14 +208,14 @@ export int nn = 43;
     }
 
     // Check that
-    // `ModuleFilesInfo::ReplaceHeaderSearchOptions(HeaderSearchOptions&)` can
+    // `PrerequisiteModules::adjustHeaderSearchOptions(HeaderSearchOptions&)` can
     // replace HeaderSearchOptions correctly.
     ParseInputs NInput = getInputs("N.cppm", *CDB);
     std::vector<std::string> CC1Args;
     std::unique_ptr<CompilerInvocation> NInvocation =
         getCompilerInvocation(NInput);
     HeaderSearchOptions &HSOpts = NInvocation->getHeaderSearchOpts();
-    NInfo.ReplaceHeaderSearchOptions(HSOpts);
+    NInfo->adjustHeaderSearchOptions(HSOpts);
 
     EXPECT_EQ(HSOpts.PrebuiltModulePaths.front(), ModuleFilesPath);
     for (auto &[ModuleName, _] : HSOpts.PrebuiltModuleFiles) {
-- 
2.42.0

